Article 10355 of comp.os.linux.development.system:
Path: smurf.noris.de!rednet!msn!faulrs!fauern!lrz-muenchen.de!informatik.tu-muenchen.de!zib-berlin.de!news.rrz.uni-hamburg.de!news.dkrz.de!dscomsa.desy.de!CERN.ch!EU.net!howland.reston.ans.net!agate!chaffee
From: chaffee@zonker.cs.berkeley.edu (Gordon Chaffee)
Newsgroups: comp.os.linux.development.system
Subject: Re: why is swapping under linux so sloooowwww
Date: 3 May 1995 23:28:32 GMT
Organization: University of California, Berkeley
Lines: 89
Message-ID: <3o93j0$om0@agate.berkeley.edu>
References: <3nob8a$bg1@coli-gate.coli.uni-sb.de> <D7qLKJ.1yx@pe1chl.ampr.org> <3o8f4c$o3i@NE3995.rabo.nl> <DAVIDM.95May3121324@piston.cs.arizona.edu>

In article <DAVIDM.95May3121324@piston.cs.arizona.edu>,
David Mosberger-Tang <davidm@cs.arizona.edu> wrote:
>In article <3o8f4c$o3i@NE3995.rabo.nl> botman@rabo.nl (Fons Botman) writes:
>
>  Fons> This has come up before.  I have tried to understand from the
>  Fons> kernel sources why, but failed.  Could some kernel guru
>  Fons> explain this (and perhaps fix the swapFILE bug)?
>
>Aside from the fact that with a swapfile you have to go through block
>mapping, ll_rw_swap_file() in drivers/block/ll_rw_blk.c reads/writes
>disk blocks one by one (e.g., with a 4KB page size, you'd typically
>get 4 1KB disk reads/writes).  This, according to Linus, causes
>page-file swapping to be "horribly slow".  It looks like it would be
>easy to fix: instead of just one "req" pointer, keep an array with
>"nb" (number of blocks) request pointers, fill them all in and add
>them to the device's request queue.  Then, wait until they all
>completed.  Linus said he plans fix it when he finds the time.

I did what David suggested and use an array of 8 requests.  This will
allow a 4K page to be completely put on the device's request queue if
the block size is 512 bytes or more.  I can't say how much this helps
anything, but if you are interested in trying to get a speedup, give it
a shot.  This is a patch against 1.2.8, but it should work without trouble
on any kernel after 1.2.4.

Gordon Chaffee
chaffee@bugs-bunny.cs.berkeley.edu

diff -u linux/drivers/block/ll_rw_blk.c.distrib linux/drivers/block/ll_rw_blk.c
--- linux/drivers/block/ll_rw_blk.c.distrib	Wed May  3 16:08:02 1995
+++ linux/drivers/block/ll_rw_blk.c	Wed May  3 16:12:26 1995
@@ -519,9 +519,9 @@
 
 void ll_rw_swap_file(int rw, int dev, unsigned int *b, int nb, char *buf)
 {
-	int i;
+	int i, j;
 	int buffersize;
-	struct request * req;
+	struct request * req[8];
 	unsigned int major = MAJOR(dev);
 	struct semaphore sem = MUTEX_LOCKED;
 
@@ -541,20 +541,32 @@
 	
 	buffersize = PAGE_SIZE / nb;
 
-	for (i=0; i<nb; i++, buf += buffersize)
+	for (j=0, i=0; i<nb;)
 	{
-		req = get_request_wait(NR_REQUEST, dev);
-		req->cmd = rw;
-		req->errors = 0;
-		req->sector = (b[i] * buffersize) >> 9;
-		req->nr_sectors = buffersize >> 9;
-		req->current_nr_sectors = buffersize >> 9;
-		req->buffer = buf;
-		req->sem = &sem;
-		req->bh = NULL;
-		req->next = NULL;
-		add_request(major+blk_dev,req);
-		down(&sem);
+		for (; j < 8 && i < nb; j++, i++, buf += buffersize)
+		{
+			if (j == 0) {
+				req[j] = get_request_wait(NR_REQUEST, dev);
+			} else {
+				req[j] = get_request(NR_REQUEST, dev);
+				if (req[j] == NULL)
+					break;
+			}
+			req[j]->cmd = rw;
+			req[j]->errors = 0;
+			req[j]->sector = (b[i] * buffersize) >> 9;
+			req[j]->nr_sectors = buffersize >> 9;
+			req[j]->current_nr_sectors = buffersize >> 9;
+			req[j]->buffer = buf;
+			req[j]->sem = &sem;
+			req[j]->bh = NULL;
+			req[j]->next = NULL;
+			add_request(major+blk_dev,req[j]);
+		}
+		while (j > 0) {
+			j--;
+			down(&sem);
+		}
 	}
 }



